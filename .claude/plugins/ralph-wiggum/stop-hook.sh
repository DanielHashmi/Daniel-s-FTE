#!/bin/bash
# Ralph Wiggum Stop Hook
#
# This script intercepts Claude Code's exit attempts and decides whether to:
# 1. Allow exit (task complete)
# 2. Block exit and re-inject prompt (task not complete)
#
# Completion Detection:
# - File-movement: Task file moved from Needs_Action/ to Done/
# - Promise-based: Output contains <promise>TASK_COMPLETE</promise>
#
# Usage: This script is called by Claude Code's stop hook mechanism

set -e

# Configuration
STATE_DIR="${PWD}/.claude/state"
VAULT_DIR="${PWD}/AI_Employee_Vault"
NEEDS_ACTION_DIR="${VAULT_DIR}/Needs_Action"
DONE_DIR="${VAULT_DIR}/Done"
LOG_FILE="${VAULT_DIR}/Logs/ralph-loop.log"

# Default values
MAX_ITERATIONS=10
DEFAULT_PROMISE="TASK_COMPLETE"

# Ensure directories exist
mkdir -p "$STATE_DIR"
mkdir -p "$(dirname "$LOG_FILE")"

log() {
    echo "[$(date -Iseconds)] $1" >> "$LOG_FILE"
}

# Find active state file
find_active_state() {
    local state_file=$(ls -t "${STATE_DIR}"/RALPH_*.json 2>/dev/null | head -1)
    echo "$state_file"
}

# Check if task file has moved to Done
check_file_movement() {
    local watch_file="$1"
    local done_folder="$2"

    if [ -z "$watch_file" ]; then
        return 1
    fi

    local filename=$(basename "$watch_file")
    local done_path="${done_folder}/${filename}"

    # Task complete if file is in Done or no longer in original location
    if [ -f "$done_path" ] || [ ! -f "$watch_file" ]; then
        return 0
    fi

    return 1
}

# Check if output contains completion promise
check_promise() {
    local output="$1"
    local promise="$2"

    if [ -z "$promise" ]; then
        promise="$DEFAULT_PROMISE"
    fi

    if echo "$output" | grep -q "<promise>${promise}</promise>"; then
        return 0
    fi

    if echo "$output" | grep -q "${promise}"; then
        return 0
    fi

    return 1
}

# Update state file iteration count
update_iteration() {
    local state_file="$1"
    local current_iteration

    if [ ! -f "$state_file" ]; then
        return
    fi

    # Read current iteration (simple jq alternative using grep/sed)
    current_iteration=$(grep -o '"current_iteration": *[0-9]*' "$state_file" | grep -o '[0-9]*' || echo "0")
    new_iteration=$((current_iteration + 1))

    # Update iteration count
    sed -i "s/\"current_iteration\": *[0-9]*/\"current_iteration\": ${new_iteration}/" "$state_file"

    # Update last_iteration_at
    local now=$(date -Iseconds)
    sed -i "s/\"last_iteration_at\": *\"[^\"]*\"/\"last_iteration_at\": \"${now}\"/" "$state_file"

    log "Iteration updated: $new_iteration"
    echo "$new_iteration"
}

# Create human review request
create_review_request() {
    local state_file="$1"
    local loop_id=$(basename "$state_file" .json)
    local review_file="${VAULT_DIR}/Pending_Approval/REVIEW_${loop_id}.md"

    local now=$(date -Iseconds)

    cat > "$review_file" << EOF
---
id: REVIEW-${loop_id}
type: review_request
action: ralph_loop_incomplete
created: ${now}
priority: high
status: pending
---

# Ralph Wiggum Loop - Human Review Required

## Loop Details
- **Loop ID:** ${loop_id}
- **Status:** Max iterations reached without completion

## Action Required
Please review the loop progress and either:
1. Manually complete the remaining work
2. Restart the loop with modified parameters
3. Mark as abandoned

---
*Generated by Ralph Wiggum Stop Hook*
EOF

    log "Created human review request: $review_file"
}

# Main logic
main() {
    local output="$1"

    # Find active state file
    local state_file=$(find_active_state)

    if [ -z "$state_file" ] || [ ! -f "$state_file" ]; then
        # No active loop, allow exit
        log "No active Ralph loop found, allowing exit"
        exit 0
    fi

    log "Found active state: $state_file"

    # Read state values
    local completion_promise=$(grep -o '"completion_promise": *"[^"]*"' "$state_file" | cut -d'"' -f4)
    local watch_file=$(grep -o '"watch_file": *"[^"]*"' "$state_file" | cut -d'"' -f4)
    local done_folder=$(grep -o '"done_folder": *"[^"]*"' "$state_file" | cut -d'"' -f4)
    local max_iterations=$(grep -o '"max_iterations": *[0-9]*' "$state_file" | grep -o '[0-9]*')
    local current_iteration=$(grep -o '"current_iteration": *[0-9]*' "$state_file" | grep -o '[0-9]*')

    # Default values
    done_folder="${done_folder:-$DONE_DIR}"
    max_iterations="${max_iterations:-$MAX_ITERATIONS}"
    current_iteration="${current_iteration:-0}"

    log "State: iteration=$current_iteration/$max_iterations, promise=$completion_promise, watch=$watch_file"

    # Check for completion
    local completed=false

    # Check promise-based completion
    if [ -n "$completion_promise" ] && check_promise "$output" "$completion_promise"; then
        log "Completion promise detected!"
        completed=true
    fi

    # Check file-movement completion
    if [ -n "$watch_file" ] && check_file_movement "$watch_file" "$done_folder"; then
        log "Watched file moved to Done!"
        completed=true
    fi

    # If completed, allow exit
    if [ "$completed" = true ]; then
        log "Task completed successfully after $current_iteration iterations"

        # Update state to completed
        sed -i 's/"status": *"[^"]*"/"status": "completed"/' "$state_file"

        # Move state to history
        local history_file="${VAULT_DIR}/Ralph_History/$(basename "$state_file")"
        mkdir -p "$(dirname "$history_file")"
        mv "$state_file" "$history_file"

        exit 0
    fi

    # Check iteration limit
    if [ "$current_iteration" -ge "$max_iterations" ]; then
        log "Max iterations ($max_iterations) reached without completion"

        # Update state to max_iterations_reached
        sed -i 's/"status": *"[^"]*"/"status": "max_iterations_reached"/' "$state_file"

        # Create human review request
        create_review_request "$state_file"

        # Move state to history
        local history_file="${VAULT_DIR}/Ralph_History/$(basename "$state_file")"
        mkdir -p "$(dirname "$history_file")"
        mv "$state_file" "$history_file"

        exit 0
    fi

    # Not complete, continue loop
    new_iteration=$(update_iteration "$state_file")

    # Read prompt from state file
    local prompt=$(grep -o '"prompt": *"[^"]*"' "$state_file" | cut -d'"' -f4)

    log "Continuing loop: iteration $new_iteration/$max_iterations"

    # Output for Claude Code to continue
    echo "RALPH_CONTINUE"
    echo "ITERATION: $new_iteration/$max_iterations"
    echo "PROMPT: $prompt"

    # Return non-zero to block exit
    exit 1
}

# Run main with output from stdin or argument
if [ -n "$1" ]; then
    main "$1"
else
    main "$(cat)"
fi
